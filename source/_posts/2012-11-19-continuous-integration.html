---
layout: post
title: "Continuous Integration "
date: 2012-11-19
comments: false
---

<div class='post'>
<br />I was completely new to the concept of&nbsp;continuous integration until my first project at TW. For my earlier projects and in internships, this is how I had approached integration (using git):<br /><br />1. Before I started working on a new story/feature I would create a new branch for the same.<br />2. If more than 1 person is working on the story, then there would be a separate branch for that person under the feature branch. So it would look something like that:<br /><br />&nbsp;Master -----------------------------------------------<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br />Search Feature &nbsp; &nbsp; &nbsp;---------------------------------<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<br />Search_Person_X &nbsp;---------------------------------<br /><br />3. When the feature is complete, the branches from Person X and Person Y and so on, will be first merged onto the search feature branch and then this will be merged onto the master.<br />4. Thus, merge conflicts, if any, will be resolved when merging in to the master or the major feature branches.<br /><br />The problem with this approach is that, if there is some major defect in the way the code is developed for the feature, there is no way to know that, until the code is merged with the master. That will happen only when the feature is completely developed. Now if the code needs to be removed, that is a lot of effort loss.<br /><br />This is where continuous integration comes to the rescue. Here is how it will work:<br /><br />1. Set-up a continuous integration server. For my first project, we had used <a href="http://www.thoughtworks-studios.com/go-agile-release-management">Go</a>&nbsp;- a ThoughtWorks Studios product.<br />2. This server will poll the Github where the repository for the project exists. The place where the code is checked in, is termed as "material". Depending on what a project uses for version control, the material will change.<br />3. When anyone checks the code into the repo, Go will do certain tasks assigned to it. (Check out next article for go server configuration steps)<br />4. Lets assume that we need the following stages:<br />compile the code, run functional tests and smoke tests and if everything is OK, we can manually deploy the app to the production server.<br />5. All these stages can be automated using a CI server - thus as soon as a new piece of code is pushed, the integration will take place, and a problem if any, will be detected at a much early stage.<br /><br />This is how continuous integration helps build a stable product and could save a lot of time and effort.<br /><br /></div>
